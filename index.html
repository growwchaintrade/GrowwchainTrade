<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Lightweight Crypto Chart (Binance live)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html,body { height:100%; margin:0; font-family:Inter, system-ui, Arial; background:#0b1220; color:#e6eef8; }
    .wrap { display:flex; flex-direction:column; height:100vh; }
    .topbar { display:flex; gap:8px; align-items:center; padding:10px; background:#071023; }
    .controls input, .controls select, .controls button { padding:6px 8px; border-radius:6px; border:none; }
    #chart { flex:1; display:flex; }
    #chartContainer { flex:1; background:#081426; }
    #info { width:320px; background:#071226; padding:12px; box-shadow: -4px 0 12px rgba(0,0,0,.4); }
    .stat { margin-bottom:8px; }
    .small { font-size:12px; color:#9fb0c8 }
    a { color:#7fd3ff }
    footer { padding:8px 12px; font-size:12px; color:#9fb0c8; background:#071226 }
  </style>
  <!-- Lightweight Charts (CDN) -->
  <script src="https://unpkg.com/lightweight-charts@4.0.0/dist/lightweight-charts.standalone.production.js"></script>
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <div style="font-weight:700;">LiteChart — live crypto (Binance)</div>
      <div class="controls" style="margin-left:12px;">
        <label class="small">Symbol</label>
        <input id="symbol" value="BTCUSDT" style="width:110px" />
        <label class="small">Interval</label>
        <select id="interval">
          <option value="1m">1m</option>
          <option value="5m">5m</option>
          <option value="15m">15m</option>
          <option value="1h">1h</option>
          <option value="4h">4h</option>
          <option value="1d">1d</option>
        </select>
        <button id="go">Load</button>
        <button id="pause">Pause WS</button>
      </div>
      <div style="margin-left:auto; font-size:13px;" class="small">Free • No account</div>
    </div>

    <div id="chart" >
      <div id="chartContainer"></div>
      <div id="info">
        <div style="font-weight:700; margin-bottom:8px" id="title">BTCUSDT • 1m</div>
        <div class="stat"><span class="small">Last price</span><div id="lastPrice" style="font-size:18px; margin-top:6px">—</div></div>
        <div class="stat"><span class="small">Candle</span><div id="candle" style="margin-top:6px">—</div></div>
        <div class="stat"><span class="small">SMA(50)</span><div id="sma50" style="margin-top:6px">—</div></div>
        <div style="margin-top:12px;" class="small">Notes:</div>
        <ul class="small">
          <li>Data from Binance public APIs (free)</li>
          <li>Deploy: GitHub Pages / Vercel / Netlify</li>
          <li>Change symbol/interval then click <b>Load</b></li>
        </ul>
        <hr style="border:none; border-top:1px solid rgba(255,255,255,0.03); margin:12px 0">
        <div class="small">Want more (indicators, drawings, alerts)? I can extend this to React or add more tools.</div>
      </div>
    </div>

    <footer>Lightweight Charts + Binance • Example starter</footer>
  </div>

<script>
(async function(){
  // DOM
  const chartContainer = document.getElementById('chartContainer');
  const symbolInput = document.getElementById('symbol');
  const intervalSelect = document.getElementById('interval');
  const goBtn = document.getElementById('go');
  const pauseBtn = document.getElementById('pause');
  const titleEl = document.getElementById('title');
  const lastPriceEl = document.getElementById('lastPrice');
  const candleEl = document.getElementById('candle');
  const sma50El = document.getElementById('sma50');

  // default
  let ws = null;
  let paused = false;

  // Create chart
  chartContainer.innerHTML = '';
  const chart = LightweightCharts.createChart(chartContainer, {
    width: chartContainer.clientWidth,
    height: chartContainer.clientHeight,
    layout: { backgroundColor: '#081426', textColor: '#e6eef8' },
    grid: { vertLines: { color: 'rgba(255,255,255,0.03)' }, horzLines: { color: 'rgba(255,255,255,0.02)' } },
    timeScale: { timeVisible: true, secondsVisible: false }
  });

  // series
  const candleSeries = chart.addCandlestickSeries({ upColor: '#26a69a', downColor:'#ef5350', borderVisible:false, wickColor: '#737b86' });
  const volumeSeries = chart.addHistogramSeries({
    color: '#26a69a', priceFormat: { type: 'volume' }, scaleMargins: { top: 0.8, bottom: 0 }
  });
  const smaSeries = chart.addLineSeries({ color: '#f4d35e', lineWidth: 2 });

  // resize handling
  window.addEventListener('resize', () => {
    chart.applyOptions({ width: chartContainer.clientWidth, height: chartContainer.clientHeight });
  });

  // helpers
  function apiKlines(symbol, interval, limit=500){
    const url = `https://api.binance.com/api/v3/klines?symbol=${symbol.toUpperCase()}&interval=${interval}&limit=${limit}`;
    return fetch(url).then(r => r.json());
  }

  function toLightK(line){
    // kline array: [ openTime, open, high, low, close, volume, closeTime, ... ]
    return {
      time: Math.floor(line[0] / 1000),
      open: parseFloat(line[1]),
      high: parseFloat(line[2]),
      low: parseFloat(line[3]),
      close: parseFloat(line[4]),
      volume: parseFloat(line[5])
    };
  }

  function computeSMA(data, length=50){
    const sma = [];
    let sum = 0;
    for(let i=0;i<data.length;i++){
      const v = data[i].close;
      sum += v;
      if(i >= length) sum -= data[i-length].close;
      if(i >= length-1) sma.push({ time: data[i].time, value: sum/length });
    }
    // align: sma length is data.length - (length-1). We'll return sparse map for series.setData usage.
    return sma;
  }

  function applyDataToChart(candles){
    const lw = candles.map(toLightK);
    candleSeries.setData(lw);
    volumeSeries.setData(lw.map(c=>({time:c.time, value:c.volume, color: c.close >= c.open ? '#26a69a' : '#ef5350'})));
    const sma = computeSMA(lw, 50);
    smaSeries.setData(sma);
    if(lw.length) {
      const last = lw[lw.length-1];
      titleEl.textContent = `${symbolInput.value.toUpperCase()} • ${intervalSelect.value}`;
      lastPriceEl.textContent = last.close.toFixed(2);
      candleEl.textContent = `O:${last.open} H:${last.high} L:${last.low} C:${last.close}`;
      const lastSma = sma.length ? sma[sma.length-1].value : null;
      sma50El.textContent = lastSma ? lastSma.toFixed(2) : '—';
    }
  }

  // WebSocket management
  function startWS(symbol, interval){
    stopWS();
    const lower = symbol.toLowerCase();
    const stream = `${lower}@kline_${interval}`;
    const url = `wss://stream.binance.com:9443/ws/${stream}`;
    ws = new WebSocket(url);
    ws.onopen = () => { console.log('WS open', url); paused = false; pauseBtn.textContent = 'Pause WS'; };
    ws.onmessage = (evt) => {
      if(paused) return;
      const msg = JSON.parse(evt.data);
      // message.k contains kline
      const k = msg.k;
      const light = {
        time: Math.floor(k.t/1000),
        open: parseFloat(k.o),
        high: parseFloat(k.h),
        low: parseFloat(k.l),
        close: parseFloat(k.c),
        volume: parseFloat(k.v)
      };
      // if k.x true => candle closed
      if(k.x){
        // append candle
        candleSeries.update(light);
        // append volume
        volumeSeries.update({ time: light.time, value: light.volume, color: light.close >= light.open ? '#26a69a' : '#ef5350' });
        // update sma by recalculating tail (cheap for demo)
        // fetch last 51 candles from chart by storing them locally would be ideal; here we request last 200 again (simple && robust)
        apiKlines(symbol, interval, 200).then(res => {
          applyDataToChart(res);
        }).catch(e=>console.warn(e));
      } else {
        // update current (incomplete) candle
        candleSeries.update(light);
        volumeSeries.update({ time: light.time, value: light.volume, color: light.close >= light.open ? '#26a69a' : '#ef5350' });
        lastPriceEl.textContent = light.close.toFixed(2);
        candleEl.textContent = `O:${light.open} H:${light.high} L:${light.low} C:${light.close}`;
      }
    };
    ws.onclose = () => { console.log('WS closed'); ws = null; pauseBtn.textContent = 'Start WS'; };
    ws.onerror = (e) => { console.warn('WS error', e); };
  }

  function stopWS(){
    if(ws){ ws.close(); ws = null; }
  }

  // load and init
  async function load(symbol, interval){
    try {
      titleEl.textContent = `${symbol.toUpperCase()} • ${interval}`;
      const raw = await apiKlines(symbol, interval, 500);
      applyDataToChart(raw);
      startWS(symbol, interval);
    } catch(err){
      alert('Failed to load data (CORS/network). Check console for details.');
      console.error(err);
    }
  }

  // UI events
  goBtn.onclick = () => {
    const s = symbolInput.value.trim();
    const i = intervalSelect.value;
    if(!s) return alert('Enter symbol like BTCUSDT');
    load(s, i);
  };

  pauseBtn.onclick = () => {
    if(!ws){ // start if not running
      startWS(symbolInput.value.trim(), intervalSelect.value);
      paused = false;
      pauseBtn.textContent = 'Pause WS';
      return;
    }
    paused = !paused;
    pauseBtn.textContent = paused ? 'Resume WS' : 'Pause WS';
  };

  // initial load
  load(symbolInput.value, intervalSelect.value);
})();
</script>
</body>
</html>
